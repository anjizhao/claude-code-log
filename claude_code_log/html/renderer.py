"""HTML renderer implementation for Claude Code transcripts."""

from functools import partial
from pathlib import Path
from typing import TYPE_CHECKING, Any, Callable, Optional, Tuple

from ..cache import get_library_version
from ..models import (
    AssistantTextContent,
    BashInputContent,
    BashOutputContent,
    CommandOutputContent,
    CompactedSummaryContent,
    DedupNoticeContent,
    HookSummaryContent,
    SessionHeaderContent,
    SlashCommandContent,
    SystemContent,
    ThinkingContentModel,
    ToolResultContent,
    ToolResultContentModel,
    ToolUseContent,
    TranscriptEntry,
    UnknownContent,
    UserMemoryContent,
    UserSlashCommandContent,
    UserTextContent,
)
from ..renderer import (
    Renderer,
    TemplateMessage,
    generate_template_messages,
    prepare_projects_index,
    title_for_projects_index,
)
from ..renderer_timings import log_timing
from .system_formatters import (
    format_dedup_notice_content,
    format_hook_summary_content,
    format_session_header_content,
    format_system_content,
)
from .user_formatters import (
    format_bash_input_content,
    format_bash_output_content,
    format_command_output_content,
    format_compacted_summary_content,
    format_slash_command_content,
    format_user_memory_content,
    format_user_slash_command_content,
    format_user_text_model_content,
)
from .assistant_formatters import (
    format_assistant_text_content,
    format_thinking_content,
    format_unknown_content,
)
from .tool_formatters import format_tool_result_content, format_tool_use_content
from .utils import css_class_from_message, get_message_emoji, get_template_environment

if TYPE_CHECKING:
    from ..cache import CacheManager


def check_html_version(html_file_path: Path) -> Optional[str]:
    """Check the version of an existing HTML file from its comment.

    Returns:
        The version string if found, None if no version comment or file doesn't exist.
    """
    if not html_file_path.exists():
        return None

    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            # Read only the first few lines to find the version comment
            for _ in range(5):  # Check first 5 lines
                line = f.readline()
                if not line:
                    break
                # Look for comment like: <!-- Generated by claude-code-log v0.3.4 -->
                if "<!-- Generated by claude-code-log v" in line:
                    # Extract version between 'v' and ' -->'
                    start = line.find("v") + 1
                    end = line.find(" -->")
                    if start > 0 and end > start:
                        return line[start:end]
    except (IOError, UnicodeDecodeError):
        pass

    return None


class HtmlRenderer(Renderer):
    """HTML renderer for Claude Code transcripts."""

    def _build_dispatcher(self) -> dict[type, Callable[..., str]]:
        """Build content type to HTML formatter mapping.

        Maps MessageContent subclasses to their HTML formatting functions.
        Handlers receive the content directly (not the full TemplateMessage).
        The cast to the correct type happens in format_content().
        """
        return {
            # System content types
            SystemContent: format_system_content,
            HookSummaryContent: format_hook_summary_content,
            SessionHeaderContent: format_session_header_content,
            DedupNoticeContent: format_dedup_notice_content,
            # User content types
            SlashCommandContent: format_slash_command_content,
            CommandOutputContent: format_command_output_content,
            BashInputContent: format_bash_input_content,
            BashOutputContent: format_bash_output_content,
            CompactedSummaryContent: format_compacted_summary_content,
            UserMemoryContent: format_user_memory_content,
            UserSlashCommandContent: format_user_slash_command_content,
            UserTextContent: format_user_text_model_content,
            # Assistant content types
            ThinkingContentModel: partial(format_thinking_content, line_threshold=10),
            AssistantTextContent: format_assistant_text_content,
            UnknownContent: format_unknown_content,
            # Tool content types
            ToolUseContent: format_tool_use_content,
            ToolResultContentModel: self._format_tool_result_content,
        }

    def _format_tool_result_content(self, content: ToolResultContentModel) -> str:
        """Format ToolResultContentModel with associated tool context."""
        tool_result = ToolResultContent(
            type="tool_result",
            tool_use_id=content.tool_use_id,
            content=content.content,
            is_error=content.is_error,
        )
        return format_tool_result_content(
            tool_result,
            content.file_path,
            content.tool_name,
        )

    def _flatten_preorder(
        self, roots: list[TemplateMessage]
    ) -> list[Tuple[TemplateMessage, str]]:
        """Flatten message tree via pre-order traversal, formatting each message.

        Traverses the tree depth-first (pre-order), formats each message's
        content to HTML, and builds a flat list of (message, html) pairs.

        Args:
            roots: Root messages (typically session headers) with children populated

        Returns:
            Flat list of (message, html_content) tuples in pre-order
        """
        flat: list[Tuple[TemplateMessage, str]] = []

        def visit(msg: TemplateMessage) -> None:
            html = self.format_content(msg)
            flat.append((msg, html))
            for child in msg.children:
                visit(child)

        for root in roots:
            visit(root)

        return flat

    def generate(
        self,
        messages: list[TranscriptEntry],
        title: Optional[str] = None,
        combined_transcript_link: Optional[str] = None,
    ) -> str:
        """Generate HTML from transcript messages."""
        import time

        t_start = time.time()

        if not title:
            title = "Claude Transcript"

        # Get root messages (tree) and session navigation from format-neutral renderer
        root_messages, session_nav = generate_template_messages(messages)

        # Flatten tree via pre-order traversal, formatting content along the way
        with log_timing("Content formatting (pre-order)", t_start):
            template_messages = self._flatten_preorder(root_messages)

        # Render template
        with log_timing("Template environment setup", t_start):
            env = get_template_environment()
            template = env.get_template("transcript.html")

        with log_timing(
            lambda: f"Template rendering ({len(html_output)} chars)", t_start
        ):
            html_output = str(
                template.render(
                    title=title,
                    messages=template_messages,
                    sessions=session_nav,
                    combined_transcript_link=combined_transcript_link,
                    library_version=get_library_version(),
                    css_class_from_message=css_class_from_message,
                    get_message_emoji=get_message_emoji,
                )
            )

        return html_output

    def generate_session(
        self,
        messages: list[TranscriptEntry],
        session_id: str,
        title: Optional[str] = None,
        cache_manager: Optional["CacheManager"] = None,
    ) -> str:
        """Generate HTML for a single session."""
        # Filter messages for this session (SummaryTranscriptEntry.sessionId is always None)
        session_messages = [msg for msg in messages if msg.sessionId == session_id]

        # Get combined transcript link if cache manager is available
        combined_link = None
        if cache_manager is not None:
            try:
                project_cache = cache_manager.get_cached_project_data()
                if project_cache and project_cache.sessions:
                    combined_link = "combined_transcripts.html"
            except Exception:
                pass

        return self.generate(
            session_messages,
            title or f"Session {session_id[:8]}",
            combined_transcript_link=combined_link,
        )

    def generate_projects_index(
        self,
        project_summaries: list[dict[str, Any]],
        from_date: Optional[str] = None,
        to_date: Optional[str] = None,
    ) -> str:
        """Generate an HTML projects index page."""
        title = title_for_projects_index(project_summaries, from_date, to_date)
        template_projects, template_summary = prepare_projects_index(project_summaries)

        env = get_template_environment()
        template = env.get_template("index.html")
        return str(
            template.render(
                title=title,
                projects=template_projects,
                summary=template_summary,
                library_version=get_library_version(),
            )
        )

    def is_outdated(self, file_path: Path) -> bool:
        """Check if an HTML file is outdated based on version.

        Returns:
            True if the file should be regenerated (missing version,
            different version, or file doesn't exist).
            False if the file is current.
        """
        html_version = check_html_version(file_path)
        current_version = get_library_version()
        # If no version found or different version, it's outdated
        return html_version != current_version


# -- Convenience Functions ----------------------------------------------------


def generate_html(
    messages: list[TranscriptEntry],
    title: Optional[str] = None,
    combined_transcript_link: Optional[str] = None,
) -> str:
    """Generate HTML from transcript messages using Jinja2 templates.

    This is a convenience function that delegates to HtmlRenderer.generate.
    """
    return HtmlRenderer().generate(messages, title, combined_transcript_link)


def generate_session_html(
    messages: list[TranscriptEntry],
    session_id: str,
    title: Optional[str] = None,
    cache_manager: Optional["CacheManager"] = None,
) -> str:
    """Generate HTML for a single session using Jinja2 templates."""
    return HtmlRenderer().generate_session(messages, session_id, title, cache_manager)


def generate_projects_index_html(
    project_summaries: list[dict[str, Any]],
    from_date: Optional[str] = None,
    to_date: Optional[str] = None,
) -> str:
    """Generate an index HTML page listing all projects using Jinja2 templates.

    This is a convenience function that delegates to HtmlRenderer.generate_projects_index.
    """
    return HtmlRenderer().generate_projects_index(project_summaries, from_date, to_date)
