"""HTML renderer implementation for Claude Code transcripts."""

from pathlib import Path
from typing import TYPE_CHECKING, Any, Optional, Tuple, cast

from ..cache import get_library_version
from ..models import (
    AssistantTextMessage,
    BashInputMessage,
    BashOutputMessage,
    CommandOutputMessage,
    CompactedSummaryMessage,
    DedupNoticeMessage,
    HookSummaryMessage,
    SessionHeaderMessage,
    SlashCommandMessage,
    SystemMessage,
    ThinkingMessage,
    ToolUseMessage,
    TranscriptEntry,
    UnknownMessage,
    UserMemoryMessage,
    UserSlashCommandMessage,
    UserTextMessage,
    # Tool input types
    AskUserQuestionInput,
    BashInput,
    EditInput,
    ExitPlanModeInput,
    GlobInput,
    MultiEditInput,
    ReadInput,
    TaskInput,
    TodoWriteInput,
    ToolUseContent,
    WriteInput,
    # Tool output types
    AskUserQuestionOutput,
    BashOutput,
    EditOutput,
    ExitPlanModeOutput,
    ReadOutput,
    TaskOutput,
    ToolResultContent,
    WriteOutput,
)
from ..renderer import (
    Renderer,
    TemplateMessage,
    generate_template_messages,
    prepare_projects_index,
    title_for_projects_index,
)
from ..renderer_timings import (
    DEBUG_TIMING,
    log_timing,
    report_timing_statistics,
    set_timing_var,
)
from ..utils import format_timestamp
from .system_formatters import (
    format_dedup_notice_content,
    format_hook_summary_content,
    format_session_header_content,
    format_system_content,
)
from .user_formatters import (
    format_bash_input_content,
    format_bash_output_content,
    format_command_output_content,
    format_compacted_summary_content,
    format_slash_command_content,
    format_user_memory_content,
    format_user_slash_command_content,
    format_user_text_model_content,
)
from .assistant_formatters import (
    format_assistant_text_content,
    format_thinking_content,
    format_unknown_content,
)
from .tool_formatters import (
    format_askuserquestion_input,
    format_askuserquestion_output,
    format_bash_input,
    format_bash_output,
    format_edit_input,
    format_edit_output,
    format_exitplanmode_input,
    format_exitplanmode_output,
    format_multiedit_input,
    format_read_input,
    format_read_output,
    format_task_input,
    format_task_output,
    format_todowrite_input,
    format_tool_result_content_raw,
    format_write_input,
    format_write_output,
    render_params_table,
)
from .utils import (
    css_class_from_message,
    escape_html,
    get_message_emoji,
    get_template_environment,
    is_session_header,
)

if TYPE_CHECKING:
    from ..cache import CacheManager


def check_html_version(html_file_path: Path) -> Optional[str]:
    """Check the version of an existing HTML file from its comment.

    Returns:
        The version string if found, None if no version comment or file doesn't exist.
    """
    if not html_file_path.exists():
        return None

    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            # Read only the first few lines to find the version comment
            for _ in range(5):  # Check first 5 lines
                line = f.readline()
                if not line:
                    break
                # Look for comment like: <!-- Generated by claude-code-log v0.3.4 -->
                if "<!-- Generated by claude-code-log v" in line:
                    # Extract version between 'v' and ' -->'
                    start = line.find("v") + 1
                    end = line.find(" -->")
                    if start > 0 and end > start:
                        return line[start:end]
    except (IOError, UnicodeDecodeError):
        pass

    return None


class HtmlRenderer(Renderer):
    """HTML renderer for Claude Code transcripts."""

    def __init__(self, image_export_mode: str = "embedded"):
        """Initialize the HTML renderer.

        Args:
            image_export_mode: Image export mode - "placeholder", "embedded", or "referenced".
                Currently only "embedded" is fully supported for HTML.
        """
        super().__init__()
        self.image_export_mode = image_export_mode

    # -------------------------------------------------------------------------
    # System Content Formatters
    # -------------------------------------------------------------------------

    def format_SystemMessage(self, message: SystemMessage) -> str:
        """Format â†’ <div class='system-content'>...</div>."""
        return format_system_content(message)

    def format_HookSummaryMessage(self, message: HookSummaryMessage) -> str:
        """Format â†’ <details class='hook-summary'>...</details>."""
        return format_hook_summary_content(message)

    def format_SessionHeaderMessage(self, message: SessionHeaderMessage) -> str:
        """Format â†’ <details class='session-header'>...</details>."""
        return format_session_header_content(message)

    def format_DedupNoticeMessage(self, message: DedupNoticeMessage) -> str:
        """Format â†’ <span class='muted'>...</span>."""
        return format_dedup_notice_content(message)

    # -------------------------------------------------------------------------
    # User Content Formatters
    # -------------------------------------------------------------------------

    def format_UserTextMessage(self, message: UserTextMessage) -> str:
        """Format â†’ rendered markdown HTML."""
        return format_user_text_model_content(message)

    def format_UserSlashCommandMessage(self, message: UserSlashCommandMessage) -> str:
        """Format â†’ <span class='slash-command'>/cmd</span>."""
        return format_user_slash_command_content(message)

    def format_SlashCommandMessage(self, message: SlashCommandMessage) -> str:
        """Format â†’ <span class='slash-command'>/cmd arg</span>."""
        return format_slash_command_content(message)

    def format_CommandOutputMessage(self, message: CommandOutputMessage) -> str:
        """Format â†’ <pre class='command-output'>...</pre>."""
        return format_command_output_content(message)

    def format_BashInputMessage(self, message: BashInputMessage) -> str:
        """Format â†’ <pre class='bash-input'>$ cmd</pre>."""
        return format_bash_input_content(message)

    def format_BashOutputMessage(self, message: BashOutputMessage) -> str:
        """Format â†’ <pre class='bash-output'>...</pre>."""
        return format_bash_output_content(message)

    def format_CompactedSummaryMessage(self, message: CompactedSummaryMessage) -> str:
        """Format â†’ <details class='compacted-summary'>...</details>."""
        return format_compacted_summary_content(message)

    def format_UserMemoryMessage(self, message: UserMemoryMessage) -> str:
        """Format â†’ <details class='user-memory'>...</details>."""
        return format_user_memory_content(message)

    # -------------------------------------------------------------------------
    # Assistant Content Formatters
    # -------------------------------------------------------------------------

    def format_AssistantTextMessage(self, message: AssistantTextMessage) -> str:
        """Format â†’ rendered markdown HTML."""
        return format_assistant_text_content(message)

    def format_ThinkingMessage(self, message: ThinkingMessage) -> str:
        """Format â†’ <details class='thinking'>...</details> (foldable if >10 lines)."""
        return format_thinking_content(message, line_threshold=10)

    def format_UnknownMessage(self, message: UnknownMessage) -> str:
        """Format â†’ <pre class='unknown'>JSON dump</pre>."""
        return format_unknown_content(message)

    # -------------------------------------------------------------------------
    # Tool Input Formatters
    # -------------------------------------------------------------------------

    def format_BashInput(self, input: BashInput) -> str:
        """Format â†’ <pre>$ command</pre>."""
        return format_bash_input(input)

    def format_ReadInput(self, input: ReadInput) -> str:
        """Format â†’ <table class='params'>file_path | ...</table>."""
        return format_read_input(input)

    def format_WriteInput(self, input: WriteInput) -> str:
        """Format â†’ file path + syntax-highlighted content preview."""
        return format_write_input(input)

    def format_EditInput(self, input: EditInput) -> str:
        """Format â†’ file path + diff of old_string/new_string."""
        return format_edit_input(input)

    def format_MultiEditInput(self, input: MultiEditInput) -> str:
        """Format â†’ file path + multiple diffs."""
        return format_multiedit_input(input)

    def format_TaskInput(self, input: TaskInput) -> str:
        """Format â†’ <div class='task-prompt'>prompt text</div>."""
        return format_task_input(input)

    def format_TodoWriteInput(self, input: TodoWriteInput) -> str:
        """Format â†’ <ul class='todo-list'>...</ul>."""
        return format_todowrite_input(input)

    def format_AskUserQuestionInput(self, input: AskUserQuestionInput) -> str:
        """Format â†’ questions as definition list."""
        return format_askuserquestion_input(input)

    def format_ExitPlanModeInput(self, input: ExitPlanModeInput) -> str:
        """Format â†’ empty string (no content)."""
        return format_exitplanmode_input(input)

    def format_ToolUseContent(self, content: ToolUseContent) -> str:
        """Format â†’ <table class='params'>key | value rows</table>."""
        return render_params_table(content.input)

    # -------------------------------------------------------------------------
    # Tool Output Formatters
    # -------------------------------------------------------------------------

    def format_ReadOutput(self, output: ReadOutput) -> str:
        """Format â†’ syntax-highlighted file content."""
        return format_read_output(output)

    def format_WriteOutput(self, output: WriteOutput) -> str:
        """Format â†’ status message (e.g. 'Wrote 42 bytes')."""
        return format_write_output(output)

    def format_EditOutput(self, output: EditOutput) -> str:
        """Format â†’ status message (e.g. 'Applied edit')."""
        return format_edit_output(output)

    def format_BashOutput(self, output: BashOutput) -> str:
        """Format â†’ <pre>stdout/stderr</pre>."""
        return format_bash_output(output)

    def format_TaskOutput(self, output: TaskOutput) -> str:
        """Format â†’ rendered markdown of task result."""
        return format_task_output(output)

    def format_AskUserQuestionOutput(self, output: AskUserQuestionOutput) -> str:
        """Format â†’ user's answers as definition list."""
        return format_askuserquestion_output(output)

    def format_ExitPlanModeOutput(self, output: ExitPlanModeOutput) -> str:
        """Format â†’ status message."""
        return format_exitplanmode_output(output)

    def format_ToolResultContent(self, output: ToolResultContent) -> str:
        """Format â†’ <pre>raw content</pre> (fallback for unknown tools)."""
        return format_tool_result_content_raw(output)

    # -------------------------------------------------------------------------
    # Tool Input Title Methods (for Renderer.title_ToolUseMessage dispatch)
    # -------------------------------------------------------------------------

    def _tool_title(
        self, message: TemplateMessage, icon: str, summary: Optional[str] = None
    ) -> str:
        """Format tool title with icon and optional summary."""
        content = cast(ToolUseMessage, message.content)
        escaped_name = escape_html(content.tool_name)
        prefix = f"{icon} " if icon else ""
        if summary:
            escaped_summary = escape_html(summary)
            return f"{prefix}{escaped_name} <span class='tool-summary'>{escaped_summary}</span>"
        return f"{prefix}{escaped_name}"

    def title_TodoWriteInput(self, message: TemplateMessage) -> str:  # noqa: ARG002
        """Title â†’ 'ğŸ“ Todo List'."""
        return "ğŸ“ Todo List"

    def title_AskUserQuestionInput(self, message: TemplateMessage) -> str:  # noqa: ARG002
        """Title â†’ 'â“ Asking questions...'."""
        return "â“ Asking questions..."

    def title_TaskInput(self, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ”§ Task <desc> (subagent_type)'."""
        content = cast(ToolUseMessage, message.content)
        input = cast(TaskInput, content.input)
        escaped_name = escape_html(content.tool_name)
        escaped_subagent = (
            escape_html(input.subagent_type) if input.subagent_type else ""
        )
        if input.description and input.subagent_type:
            escaped_desc = escape_html(input.description)
            return f"ğŸ”§ {escaped_name} <span class='tool-summary'>{escaped_desc}</span> <span class='tool-subagent'>({escaped_subagent})</span>"
        elif input.description:
            return self._tool_title(message, "ğŸ”§", input.description)
        elif input.subagent_type:
            return f"ğŸ”§ {escaped_name} <span class='tool-subagent'>({escaped_subagent})</span>"
        return f"ğŸ”§ {escaped_name}"

    def title_EditInput(self, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ“ Edit <file_path>'."""
        input = cast(EditInput, cast(ToolUseMessage, message.content).input)
        return self._tool_title(message, "ğŸ“", input.file_path)

    def title_WriteInput(self, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ“ Write <file_path>'."""
        input = cast(WriteInput, cast(ToolUseMessage, message.content).input)
        return self._tool_title(message, "ğŸ“", input.file_path)

    def title_ReadInput(self, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ“„ Read <file_path>[, lines N-M]'."""
        input = cast(ReadInput, cast(ToolUseMessage, message.content).input)
        summary = input.file_path
        # Add line range info if available
        if input.limit is not None:
            offset = input.offset or 0
            if input.limit == 1:
                summary = f"{summary}, line {offset + 1}"
            else:
                summary = f"{summary}, lines {offset + 1}-{offset + input.limit}"
        return self._tool_title(message, "ğŸ“„", summary)

    def title_GlobInput(self, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ” Glob <pattern>[ in path]'."""
        input = cast(GlobInput, cast(ToolUseMessage, message.content).input)
        summary = input.pattern
        if input.path:
            summary = f"{summary} in {input.path}"
        return self._tool_title(message, "ğŸ”", summary)

    def title_BashInput(self, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ’» Bash <description>'."""
        input = cast(BashInput, cast(ToolUseMessage, message.content).input)
        return self._tool_title(message, "ğŸ’»", input.description)

    def _flatten_preorder(
        self, roots: list[TemplateMessage]
    ) -> Tuple[
        list[Tuple[TemplateMessage, str, str, str]],
        list[Tuple[str, list[Tuple[float, str]]]],
    ]:
        """Flatten message tree via pre-order traversal, formatting each message.

        Traverses the tree depth-first (pre-order), computes title and formats
        content to HTML, building a flat list of (message, title, html, timestamp) tuples.

        Also tracks timing statistics for Markdown and Pygments operations when
        DEBUG_TIMING is enabled.

        Args:
            roots: Root messages (typically session headers) with children populated

        Returns:
            Tuple of:
            - Flat list of (message, title, html_content, formatted_timestamp) tuples
            - Operation timing data for reporting: [("Markdown", timings), ("Pygments", timings)]
        """
        flat: list[Tuple[TemplateMessage, str, str, str]] = []

        # Initialize timing tracking for expensive operations
        markdown_timings: list[Tuple[float, str]] = []
        pygments_timings: list[Tuple[float, str]] = []
        set_timing_var("_markdown_timings", markdown_timings)
        set_timing_var("_pygments_timings", pygments_timings)

        def visit(msg: TemplateMessage) -> None:
            # Update current message ID for timing tracking
            set_timing_var("_current_msg_id", msg.message_id)
            title = self.title_content(msg)
            html = self.format_content(msg)
            formatted_ts = format_timestamp(msg.meta.timestamp if msg.meta else None)
            flat.append((msg, title, html, formatted_ts))
            for child in msg.children:
                visit(child)

        for root in roots:
            visit(root)

        # Return timing data for reporting
        operation_timings: list[Tuple[str, list[Tuple[float, str]]]] = [
            ("Markdown", markdown_timings),
            ("Pygments", pygments_timings),
        ]

        return flat, operation_timings

    def generate(
        self,
        messages: list[TranscriptEntry],
        title: Optional[str] = None,
        combined_transcript_link: Optional[str] = None,
        output_dir: Optional[Path] = None,  # noqa: ARG002
    ) -> str:
        """Generate HTML from transcript messages."""
        import time

        t_start = time.time()

        if not title:
            title = "Claude Transcript"

        # Get root messages (tree) and session navigation from format-neutral renderer
        root_messages, session_nav, _ = generate_template_messages(messages)

        # Flatten tree via pre-order traversal, formatting content along the way
        with log_timing("Content formatting (pre-order)", t_start):
            template_messages, operation_timings = self._flatten_preorder(root_messages)

        # Report timing statistics for Markdown/Pygments operations
        if DEBUG_TIMING:
            report_timing_statistics([], operation_timings)

        # Render template
        with log_timing("Template environment setup", t_start):
            env = get_template_environment()
            template = env.get_template("transcript.html")

        with log_timing(
            lambda: f"Template rendering ({len(html_output)} chars)", t_start
        ):
            html_output = str(
                template.render(
                    title=title,
                    messages=template_messages,
                    sessions=session_nav,
                    combined_transcript_link=combined_transcript_link,
                    library_version=get_library_version(),
                    css_class_from_message=css_class_from_message,
                    get_message_emoji=get_message_emoji,
                    is_session_header=is_session_header,
                )
            )

        return html_output

    def generate_session(
        self,
        messages: list[TranscriptEntry],
        session_id: str,
        title: Optional[str] = None,
        cache_manager: Optional["CacheManager"] = None,
        output_dir: Optional[Path] = None,  # noqa: ARG002
    ) -> str:
        """Generate HTML for a single session."""
        # Filter messages for this session (SummaryTranscriptEntry.sessionId is always None)
        session_messages = [msg for msg in messages if msg.sessionId == session_id]

        # Get combined transcript link if cache manager is available
        combined_link = None
        if cache_manager is not None:
            try:
                project_cache = cache_manager.get_cached_project_data()
                if project_cache and project_cache.sessions:
                    combined_link = "combined_transcripts.html"
            except Exception:
                pass

        return self.generate(
            session_messages,
            title or f"Session {session_id[:8]}",
            combined_transcript_link=combined_link,
        )

    def generate_projects_index(
        self,
        project_summaries: list[dict[str, Any]],
        from_date: Optional[str] = None,
        to_date: Optional[str] = None,
    ) -> str:
        """Generate an HTML projects index page."""
        title = title_for_projects_index(project_summaries, from_date, to_date)
        template_projects, template_summary = prepare_projects_index(project_summaries)

        env = get_template_environment()
        template = env.get_template("index.html")
        return str(
            template.render(
                title=title,
                projects=template_projects,
                summary=template_summary,
                library_version=get_library_version(),
            )
        )

    def is_outdated(self, file_path: Path) -> bool:
        """Check if an HTML file is outdated based on version.

        Returns:
            True if the file should be regenerated (missing version,
            different version, or file doesn't exist).
            False if the file is current.
        """
        html_version = check_html_version(file_path)
        current_version = get_library_version()
        # If no version found or different version, it's outdated
        return html_version != current_version


# -- Convenience Functions ----------------------------------------------------


def generate_html(
    messages: list[TranscriptEntry],
    title: Optional[str] = None,
    combined_transcript_link: Optional[str] = None,
) -> str:
    """Generate HTML from transcript messages using Jinja2 templates.

    This is a convenience function that delegates to HtmlRenderer.generate.
    """
    return HtmlRenderer().generate(messages, title, combined_transcript_link)


def generate_session_html(
    messages: list[TranscriptEntry],
    session_id: str,
    title: Optional[str] = None,
    cache_manager: Optional["CacheManager"] = None,
) -> str:
    """Generate HTML for a single session using Jinja2 templates."""
    return HtmlRenderer().generate_session(messages, session_id, title, cache_manager)


def generate_projects_index_html(
    project_summaries: list[dict[str, Any]],
    from_date: Optional[str] = None,
    to_date: Optional[str] = None,
) -> str:
    """Generate an index HTML page listing all projects using Jinja2 templates.

    This is a convenience function that delegates to HtmlRenderer.generate_projects_index.
    """
    return HtmlRenderer().generate_projects_index(project_summaries, from_date, to_date)
