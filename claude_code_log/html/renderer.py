"""HTML renderer implementation for Claude Code transcripts."""

from pathlib import Path
from typing import TYPE_CHECKING, Any, Optional, Tuple

from ..cache import get_library_version
from ..models import (
    AssistantTextContent,
    BashInputContent,
    BashOutputContent,
    CommandOutputContent,
    CompactedSummaryContent,
    DedupNoticeContent,
    HookSummaryContent,
    ImageContent,
    SessionHeaderContent,
    SlashCommandContent,
    SystemContent,
    ThinkingContentModel,
    ToolResultContent,
    ToolResultContentModel,
    ToolUseContent,
    TranscriptEntry,
    UnknownContent,
    UserMemoryContent,
    UserTextContent,
)
from ..renderer import (
    Renderer,
    TemplateMessage,
    generate_template_messages,
    prepare_projects_index,
    title_for_projects_index,
)
from ..renderer_timings import log_timing
from .system_formatters import (
    format_dedup_notice_content,
    format_hook_summary_content,
    format_session_header_content,
    format_system_content,
)
from .user_formatters import (
    format_bash_input_content,
    format_bash_output_content,
    format_command_output_content,
    format_compacted_summary_content,
    format_slash_command_content,
    format_user_memory_content,
    format_user_text_model_content,
)
from .assistant_formatters import (
    format_assistant_text_content,
    format_image_content,
    format_thinking_content,
    format_unknown_content,
)
from .tool_formatters import format_tool_result_content, format_tool_use_content
from .utils import css_class_from_message, get_message_emoji, get_template_environment

if TYPE_CHECKING:
    from ..cache import CacheManager


def check_html_version(html_file_path: Path) -> Optional[str]:
    """Check the version of an existing HTML file from its comment.

    Returns:
        The version string if found, None if no version comment or file doesn't exist.
    """
    if not html_file_path.exists():
        return None

    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            # Read only the first few lines to find the version comment
            for _ in range(5):  # Check first 5 lines
                line = f.readline()
                if not line:
                    break
                # Look for comment like: <!-- Generated by claude-code-log v0.3.4 -->
                if "<!-- Generated by claude-code-log v" in line:
                    # Extract version between 'v' and ' -->'
                    start = line.find("v") + 1
                    end = line.find(" -->")
                    if start > 0 and end > start:
                        return line[start:end]
    except (IOError, UnicodeDecodeError):
        pass

    return None


class HtmlRenderer(Renderer):
    """HTML renderer for Claude Code transcripts."""

    def _format_message_content(self, message: TemplateMessage) -> str:
        """Format structured content to HTML for a single message.

        Args:
            message: TemplateMessage with content model to format

        Returns:
            HTML string for the message content, or empty string if no content
        """
        if message.content is None:
            return ""

        # Dispatch to appropriate formatter based on content type
        if isinstance(message.content, SystemContent):
            return format_system_content(message.content)
        elif isinstance(message.content, HookSummaryContent):
            return format_hook_summary_content(message.content)
        elif isinstance(message.content, SessionHeaderContent):
            return format_session_header_content(message.content)
        elif isinstance(message.content, DedupNoticeContent):
            return format_dedup_notice_content(message.content)
        elif isinstance(message.content, SlashCommandContent):
            return format_slash_command_content(message.content)
        elif isinstance(message.content, CommandOutputContent):
            return format_command_output_content(message.content)
        elif isinstance(message.content, BashInputContent):
            return format_bash_input_content(message.content)
        elif isinstance(message.content, BashOutputContent):
            return format_bash_output_content(message.content)
        elif isinstance(message.content, ThinkingContentModel):
            return format_thinking_content(message.content, line_threshold=10)
        elif isinstance(message.content, AssistantTextContent):
            return format_assistant_text_content(message.content)
        elif isinstance(message.content, ImageContent):
            return format_image_content(message.content)
        elif isinstance(message.content, ToolUseContent):
            return format_tool_use_content(message.content)
        elif isinstance(message.content, ToolResultContentModel):
            # Create ToolResultContent from the model for formatting
            tool_result = ToolResultContent(
                type="tool_result",
                tool_use_id=message.content.tool_use_id,
                content=message.content.content,
                is_error=message.content.is_error,
            )
            return format_tool_result_content(
                tool_result,
                message.content.file_path,
                message.content.tool_name,
            )
        # User message content types
        elif isinstance(message.content, CompactedSummaryContent):
            return format_compacted_summary_content(message.content)
        elif isinstance(message.content, UserMemoryContent):
            return format_user_memory_content(message.content)
        elif isinstance(message.content, UserTextContent):
            # Check if this is a slash command expanded prompt (via modifiers)
            if message.modifiers and message.modifiers.is_slash_command:
                # Slash command expanded prompts are markdown (LLM-generated)
                from .utils import render_markdown_collapsible

                return render_markdown_collapsible(
                    message.content.text,
                    "slash-command-content",
                    line_threshold=20,
                    preview_line_count=5,
                )
            else:
                return format_user_text_model_content(message.content)
        elif isinstance(message.content, UnknownContent):
            return format_unknown_content(message.content)
        # Future content types will be added here as they are migrated
        return ""

    def _flatten_preorder(
        self, roots: list[TemplateMessage]
    ) -> list[Tuple[TemplateMessage, str]]:
        """Flatten message tree via pre-order traversal, formatting each message.

        Traverses the tree depth-first (pre-order), formats each message's
        content to HTML, and builds a flat list of (message, html) pairs.

        Args:
            roots: Root messages (typically session headers) with children populated

        Returns:
            Flat list of (message, html_content) tuples in pre-order
        """
        flat: list[Tuple[TemplateMessage, str]] = []

        def visit(msg: TemplateMessage) -> None:
            html = self._format_message_content(msg)
            flat.append((msg, html))
            for child in msg.children:
                visit(child)

        for root in roots:
            visit(root)

        return flat

    def generate(
        self,
        messages: list[TranscriptEntry],
        title: Optional[str] = None,
        combined_transcript_link: Optional[str] = None,
    ) -> str:
        """Generate HTML from transcript messages."""
        import time

        t_start = time.time()

        if not title:
            title = "Claude Transcript"

        # Get root messages (tree) and session navigation from format-neutral renderer
        root_messages, session_nav = generate_template_messages(messages)

        # Flatten tree via pre-order traversal, formatting content along the way
        with log_timing("Content formatting (pre-order)", t_start):
            template_messages = self._flatten_preorder(root_messages)

        # Render template
        with log_timing("Template environment setup", t_start):
            env = get_template_environment()
            template = env.get_template("transcript.html")

        with log_timing(
            lambda: f"Template rendering ({len(html_output)} chars)", t_start
        ):
            html_output = str(
                template.render(
                    title=title,
                    messages=template_messages,
                    sessions=session_nav,
                    combined_transcript_link=combined_transcript_link,
                    library_version=get_library_version(),
                    css_class_from_message=css_class_from_message,
                    get_message_emoji=get_message_emoji,
                )
            )

        return html_output

    def generate_session(
        self,
        messages: list[TranscriptEntry],
        session_id: str,
        title: Optional[str] = None,
        cache_manager: Optional["CacheManager"] = None,
    ) -> str:
        """Generate HTML for a single session."""
        # Filter messages for this session (SummaryTranscriptEntry.sessionId is always None)
        session_messages = [msg for msg in messages if msg.sessionId == session_id]

        # Get combined transcript link if cache manager is available
        combined_link = None
        if cache_manager is not None:
            try:
                project_cache = cache_manager.get_cached_project_data()
                if project_cache and project_cache.sessions:
                    combined_link = "combined_transcripts.html"
            except Exception:
                pass

        return self.generate(
            session_messages,
            title or f"Session {session_id[:8]}",
            combined_transcript_link=combined_link,
        )

    def generate_projects_index(
        self,
        project_summaries: list[dict[str, Any]],
        from_date: Optional[str] = None,
        to_date: Optional[str] = None,
    ) -> str:
        """Generate an HTML projects index page."""
        title = title_for_projects_index(project_summaries, from_date, to_date)
        template_projects, template_summary = prepare_projects_index(project_summaries)

        env = get_template_environment()
        template = env.get_template("index.html")
        return str(
            template.render(
                title=title,
                projects=template_projects,
                summary=template_summary,
                library_version=get_library_version(),
            )
        )

    def is_outdated(self, file_path: Path) -> bool:
        """Check if an HTML file is outdated based on version.

        Returns:
            True if the file should be regenerated (missing version,
            different version, or file doesn't exist).
            False if the file is current.
        """
        html_version = check_html_version(file_path)
        current_version = get_library_version()
        # If no version found or different version, it's outdated
        return html_version != current_version


# -- Convenience Functions ----------------------------------------------------


def generate_html(
    messages: list[TranscriptEntry],
    title: Optional[str] = None,
    combined_transcript_link: Optional[str] = None,
) -> str:
    """Generate HTML from transcript messages using Jinja2 templates.

    This is a convenience function that delegates to HtmlRenderer.generate.
    """
    return HtmlRenderer().generate(messages, title, combined_transcript_link)


def generate_session_html(
    messages: list[TranscriptEntry],
    session_id: str,
    title: Optional[str] = None,
    cache_manager: Optional["CacheManager"] = None,
) -> str:
    """Generate HTML for a single session using Jinja2 templates."""
    return HtmlRenderer().generate_session(messages, session_id, title, cache_manager)


def generate_projects_index_html(
    project_summaries: list[dict[str, Any]],
    from_date: Optional[str] = None,
    to_date: Optional[str] = None,
) -> str:
    """Generate an index HTML page listing all projects using Jinja2 templates.

    This is a convenience function that delegates to HtmlRenderer.generate_projects_index.
    """
    return HtmlRenderer().generate_projects_index(project_summaries, from_date, to_date)
