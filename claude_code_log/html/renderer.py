"""HTML renderer implementation for Claude Code transcripts."""

from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING, Any, Optional, Tuple, cast

from ..cache import get_library_version
from ..models import (
    AssistantTextMessage,
    BashInputMessage,
    BashOutputMessage,
    CommandOutputMessage,
    CompactedSummaryMessage,
    HookSummaryMessage,
    ImageContent,
    SessionHeaderMessage,
    SlashCommandMessage,
    SystemMessage,
    ThinkingMessage,
    ToolUseMessage,
    TranscriptEntry,
    UnknownMessage,
    UserMemoryMessage,
    UserSlashCommandMessage,
    UserTextMessage,
    # Tool input types
    AskUserQuestionInput,
    BashInput,
    EditInput,
    ExitPlanModeInput,
    GlobInput,
    MultiEditInput,
    ReadInput,
    TaskInput,
    TodoWriteInput,
    ToolUseContent,
    WebSearchInput,
    WebFetchInput,
    WriteInput,
    # Tool output types
    AskUserQuestionOutput,
    BashOutput,
    EditOutput,
    ExitPlanModeOutput,
    ReadOutput,
    TaskOutput,
    ToolResultContent,
    WebSearchOutput,
    WebFetchOutput,
    WriteOutput,
)
from ..renderer import (
    Renderer,
    TemplateMessage,
    generate_template_messages,
    prepare_projects_index,
    title_for_projects_index,
)
from ..renderer_timings import (
    DEBUG_TIMING,
    log_timing,
    report_timing_statistics,
    set_timing_var,
)
from ..utils import format_timestamp
from .system_formatters import (
    format_hook_summary_content,
    format_session_header_content,
    format_system_content,
)
from .user_formatters import (
    format_bash_input_content,
    format_bash_output_content,
    format_command_output_content,
    format_compacted_summary_content,
    format_slash_command_content,
    format_user_memory_content,
    format_user_slash_command_content,
    format_user_text_model_content,
)
from .assistant_formatters import (
    format_assistant_text_content,
    format_thinking_content,
    format_unknown_content,
)
from .tool_formatters import (
    format_askuserquestion_input,
    format_askuserquestion_output,
    format_bash_input,
    format_bash_output,
    format_edit_input,
    format_edit_output,
    format_exitplanmode_input,
    format_exitplanmode_output,
    format_multiedit_input,
    format_read_input,
    format_read_output,
    format_task_input,
    format_task_output,
    format_todowrite_input,
    format_tool_result_content_raw,
    format_websearch_input,
    format_websearch_output,
    format_webfetch_input,
    format_webfetch_output,
    format_write_input,
    format_write_output,
    render_params_table,
)
from .utils import (
    css_class_from_message,
    escape_html,
    get_message_emoji,
    get_template_environment,
    is_session_header,
)

if TYPE_CHECKING:
    from ..cache import CacheManager


def check_html_version(html_file_path: Path) -> Optional[str]:
    """Check the version of an existing HTML file from its comment.

    Returns:
        The version string if found, None if no version comment or file doesn't exist.
    """
    if not html_file_path.exists():
        return None

    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            # Read only the first few lines to find the version comment
            for _ in range(5):  # Check first 5 lines
                line = f.readline()
                if not line:
                    break
                # Look for comment like: <!-- Generated by claude-code-log v0.3.4 -->
                if "<!-- Generated by claude-code-log v" in line:
                    # Extract version between 'v' and ' -->'
                    start = line.find("v") + 1
                    end = line.find(" -->")
                    if start > 0 and end > start:
                        return line[start:end]
    except (IOError, UnicodeDecodeError):
        pass

    return None


class HtmlRenderer(Renderer):
    """HTML renderer for Claude Code transcripts."""

    def __init__(self, image_export_mode: str = "embedded"):
        """Initialize the HTML renderer.

        Args:
            image_export_mode: Image export mode - "placeholder", "embedded", or "referenced".
        """
        super().__init__()
        self.image_export_mode = image_export_mode
        self._output_dir: Path | None = None
        self._image_counter = 0

    # -------------------------------------------------------------------------
    # Private Utility Methods
    # -------------------------------------------------------------------------

    def _format_image(self, image: ImageContent) -> str:
        """Format image based on export mode."""
        from ..image_export import export_image

        self._image_counter += 1
        src = export_image(
            image,
            self.image_export_mode,
            output_dir=self._output_dir,
            counter=self._image_counter,
        )
        if src is None:
            return "[Image]"
        return f'<img src="{src}" alt="image" class="uploaded-image" />'

    # -------------------------------------------------------------------------
    # System Content Formatters
    # -------------------------------------------------------------------------

    def format_SystemMessage(self, content: SystemMessage, _: TemplateMessage) -> str:
        return format_system_content(content)

    def format_HookSummaryMessage(
        self, content: HookSummaryMessage, _: TemplateMessage
    ) -> str:
        return format_hook_summary_content(content)

    def format_SessionHeaderMessage(
        self, content: SessionHeaderMessage, _: TemplateMessage
    ) -> str:
        return format_session_header_content(content)

    # -------------------------------------------------------------------------
    # User Content Formatters
    # -------------------------------------------------------------------------

    def format_UserTextMessage(
        self, content: UserTextMessage, _: TemplateMessage
    ) -> str:
        return format_user_text_model_content(
            content, image_formatter=self._format_image
        )

    def format_UserSlashCommandMessage(
        self, content: UserSlashCommandMessage, _: TemplateMessage
    ) -> str:
        return format_user_slash_command_content(content)

    def format_SlashCommandMessage(
        self, content: SlashCommandMessage, _: TemplateMessage
    ) -> str:
        return format_slash_command_content(content)

    def format_CommandOutputMessage(
        self, content: CommandOutputMessage, _: TemplateMessage
    ) -> str:
        return format_command_output_content(content)

    def format_BashInputMessage(
        self, content: BashInputMessage, _: TemplateMessage
    ) -> str:
        return format_bash_input_content(content)

    def format_BashOutputMessage(
        self, content: BashOutputMessage, _: TemplateMessage
    ) -> str:
        return format_bash_output_content(content)

    def format_CompactedSummaryMessage(
        self, content: CompactedSummaryMessage, _: TemplateMessage
    ) -> str:
        return format_compacted_summary_content(content)

    def format_UserMemoryMessage(
        self, content: UserMemoryMessage, _: TemplateMessage
    ) -> str:
        return format_user_memory_content(content)

    # -------------------------------------------------------------------------
    # Assistant Content Formatters
    # -------------------------------------------------------------------------

    def format_AssistantTextMessage(
        self, content: AssistantTextMessage, _: TemplateMessage
    ) -> str:
        return format_assistant_text_content(
            content, image_formatter=self._format_image
        )

    def format_ThinkingMessage(
        self, content: ThinkingMessage, _: TemplateMessage
    ) -> str:
        """Format â†’ <details class='thinking'>...</details> (foldable if >10 lines)."""
        return format_thinking_content(content, line_threshold=10)

    def format_UnknownMessage(self, content: UnknownMessage, _: TemplateMessage) -> str:
        """Format â†’ <pre class='unknown'>JSON dump</pre>."""
        return format_unknown_content(content)

    # -------------------------------------------------------------------------
    # Tool Input Formatters
    # -------------------------------------------------------------------------

    def format_BashInput(self, input: BashInput, _: TemplateMessage) -> str:
        """Format â†’ <pre>$ command</pre>."""
        return format_bash_input(input)

    def format_ReadInput(self, input: ReadInput, _: TemplateMessage) -> str:
        """Format â†’ <table class='params'>file_path | ...</table>."""
        return format_read_input(input)

    def format_WriteInput(self, input: WriteInput, _: TemplateMessage) -> str:
        """Format â†’ file path + syntax-highlighted content preview."""
        return format_write_input(input)

    def format_EditInput(self, input: EditInput, _: TemplateMessage) -> str:
        """Format â†’ file path + diff of old_string/new_string."""
        return format_edit_input(input)

    def format_MultiEditInput(self, input: MultiEditInput, _: TemplateMessage) -> str:
        """Format â†’ file path + multiple diffs."""
        return format_multiedit_input(input)

    def format_TaskInput(self, input: TaskInput, _: TemplateMessage) -> str:
        """Format â†’ <div class='task-prompt'>prompt text</div>."""
        return format_task_input(input)

    def format_TodoWriteInput(self, input: TodoWriteInput, _: TemplateMessage) -> str:
        """Format â†’ <ul class='todo-list'>...</ul>."""
        return format_todowrite_input(input)

    def format_AskUserQuestionInput(
        self, input: AskUserQuestionInput, _: TemplateMessage
    ) -> str:
        """Format â†’ questions as definition list."""
        return format_askuserquestion_input(input)

    def format_ExitPlanModeInput(
        self, input: ExitPlanModeInput, _: TemplateMessage
    ) -> str:
        """Format â†’ empty string (no content)."""
        return format_exitplanmode_input(input)

    def format_WebSearchInput(self, input: WebSearchInput, _: TemplateMessage) -> str:
        """Format â†’ search query display."""
        return format_websearch_input(input)

    def format_ToolUseContent(self, content: ToolUseContent, _: TemplateMessage) -> str:
        """Format â†’ <table class='params'>key | value rows</table>."""
        return render_params_table(content.input)

    # -------------------------------------------------------------------------
    # Tool Output Formatters
    # -------------------------------------------------------------------------

    def format_ReadOutput(self, output: ReadOutput, _: TemplateMessage) -> str:
        """Format â†’ syntax-highlighted file content."""
        return format_read_output(output)

    def format_WriteOutput(self, output: WriteOutput, _: TemplateMessage) -> str:
        """Format â†’ status message (e.g. 'Wrote 42 bytes')."""
        return format_write_output(output)

    def format_EditOutput(self, output: EditOutput, _: TemplateMessage) -> str:
        """Format â†’ status message (e.g. 'Applied edit')."""
        return format_edit_output(output)

    def format_BashOutput(self, output: BashOutput, _: TemplateMessage) -> str:
        """Format â†’ <pre>stdout/stderr</pre>."""
        return format_bash_output(output)

    def format_TaskOutput(self, output: TaskOutput, _: TemplateMessage) -> str:
        """Format â†’ rendered markdown of task result."""
        return format_task_output(output)

    def format_AskUserQuestionOutput(
        self, output: AskUserQuestionOutput, _: TemplateMessage
    ) -> str:
        """Format â†’ user's answers as definition list."""
        return format_askuserquestion_output(output)

    def format_ExitPlanModeOutput(
        self, output: ExitPlanModeOutput, _: TemplateMessage
    ) -> str:
        """Format â†’ status message."""
        return format_exitplanmode_output(output)

    def format_WebSearchOutput(
        self, output: WebSearchOutput, _: TemplateMessage
    ) -> str:
        """Format â†’ list of clickable search result links."""
        return format_websearch_output(output)

    def format_ToolResultContent(
        self, output: ToolResultContent, _: TemplateMessage
    ) -> str:
        """Format â†’ <pre>raw content</pre> (fallback for unknown tools)."""
        return format_tool_result_content_raw(output)

    def format_WebFetchInput(self, input: WebFetchInput, _: TemplateMessage) -> str:
        """Format â†’ prompt text if long, empty if shown in title."""
        return format_webfetch_input(input)

    def format_WebFetchOutput(self, output: WebFetchOutput, _: TemplateMessage) -> str:
        """Format â†’ collapsible markdown with metadata badge."""
        return format_webfetch_output(output)

    # -------------------------------------------------------------------------
    # Tool Input Title Methods (for Renderer.title_ToolUseMessage dispatch)
    # -------------------------------------------------------------------------

    def _tool_title(
        self, message: TemplateMessage, icon: str, summary: Optional[str] = None
    ) -> str:
        """Format tool title with icon and optional summary."""
        content = cast(ToolUseMessage, message.content)
        escaped_name = escape_html(content.tool_name)
        prefix = f"{icon} " if icon else ""
        if summary:
            escaped_summary = escape_html(summary)
            return f"{prefix}{escaped_name} <span class='tool-summary'>{escaped_summary}</span>"
        return f"{prefix}{escaped_name}"

    def title_TodoWriteInput(
        self, _input: TodoWriteInput, _message: TemplateMessage
    ) -> str:
        """Title â†’ 'ğŸ“ Todo List'."""
        return "ğŸ“ Todo List"

    def title_AskUserQuestionInput(
        self, _input: AskUserQuestionInput, _message: TemplateMessage
    ) -> str:
        """Title â†’ 'â“ Asking questions...'."""
        return "â“ Asking questions..."

    def title_TaskInput(self, input: TaskInput, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ”§ Task <desc> (subagent_type)'."""
        content = cast(ToolUseMessage, message.content)
        escaped_name = escape_html(content.tool_name)
        escaped_subagent = (
            escape_html(input.subagent_type) if input.subagent_type else ""
        )
        if input.description and input.subagent_type:
            escaped_desc = escape_html(input.description)
            return f"ğŸ”§ {escaped_name} <span class='tool-summary'>{escaped_desc}</span> <span class='tool-subagent'>({escaped_subagent})</span>"
        elif input.description:
            return self._tool_title(message, "ğŸ”§", input.description)
        elif input.subagent_type:
            return f"ğŸ”§ {escaped_name} <span class='tool-subagent'>({escaped_subagent})</span>"
        return f"ğŸ”§ {escaped_name}"

    def title_EditInput(self, input: EditInput, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ“ Edit <file_path>'."""
        return self._tool_title(message, "ğŸ“", input.file_path)

    def title_WriteInput(self, input: WriteInput, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ“ Write <file_path>'."""
        return self._tool_title(message, "ğŸ“", input.file_path)

    def title_ReadInput(self, input: ReadInput, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ“„ Read <file_path>[, lines N-M]'."""
        summary = input.file_path
        # Add line range info if available
        if input.limit is not None:
            offset = input.offset or 0
            if input.limit == 1:
                summary = f"{summary}, line {offset + 1}"
            else:
                summary = f"{summary}, lines {offset + 1}-{offset + input.limit}"
        return self._tool_title(message, "ğŸ“„", summary)

    def title_GlobInput(self, input: GlobInput, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ” Glob <pattern>[ in path]'."""
        summary = input.pattern
        if input.path:
            summary = f"{summary} in {input.path}"
        return self._tool_title(message, "ğŸ”", summary)

    def title_BashInput(self, input: BashInput, message: TemplateMessage) -> str:
        """Title â†’ 'ğŸ’» Bash <description>'."""
        return self._tool_title(message, "ğŸ’»", input.description)

    def title_WebSearchInput(
        self, input: WebSearchInput, message: TemplateMessage
    ) -> str:
        """Title â†’ 'ğŸ” WebSearch <query>'."""
        return self._tool_title(message, "ğŸ”", input.query)

    def title_WebFetchInput(
        self, input: WebFetchInput, message: TemplateMessage
    ) -> str:
        """Title â†’ 'ğŸŒ WebFetch <url>'."""
        return self._tool_title(message, "ğŸŒ", input.url)

    def _flatten_preorder(
        self, roots: list[TemplateMessage]
    ) -> list[Tuple[TemplateMessage, str, str, str]]:
        """Flatten message tree via pre-order traversal, formatting each message.

        Traverses the tree depth-first (pre-order), computes title and formats
        content to HTML, building a flat list of (message, title, html, timestamp) tuples.

        Also tracks and reports timing statistics for Markdown and Pygments operations
        when DEBUG_TIMING is enabled.

        Args:
            roots: Root messages (typically session headers) with children populated

        Returns:
            Flat list of (message, title, html_content, formatted_timestamp) tuples
        """
        flat: list[Tuple[TemplateMessage, str, str, str]] = []

        # Initialize timing tracking for expensive operations
        markdown_timings: list[Tuple[float, str]] = []
        pygments_timings: list[Tuple[float, str]] = []
        set_timing_var("_markdown_timings", markdown_timings)
        set_timing_var("_pygments_timings", pygments_timings)

        def visit(msg: TemplateMessage) -> None:
            # Update current message ID for timing tracking
            set_timing_var("_current_msg_id", msg.message_id)
            title = self.title_content(msg)
            html = self.format_content(msg)
            formatted_ts = format_timestamp(msg.meta.timestamp if msg.meta else None)
            flat.append((msg, title, html, formatted_ts))
            for child in msg.children:
                visit(child)

        for root in roots:
            visit(root)

        # Report timing statistics for Markdown/Pygments operations
        if DEBUG_TIMING:
            report_timing_statistics(
                [
                    ("Markdown", markdown_timings),
                    ("Pygments", pygments_timings),
                ]
            )

        return flat

    def generate(
        self,
        messages: list[TranscriptEntry],
        title: Optional[str] = None,
        combined_transcript_link: Optional[str] = None,
        output_dir: Optional[Path] = None,
        page_info: Optional[dict[str, Any]] = None,
        page_stats: Optional[dict[str, Any]] = None,
    ) -> str:
        """Generate HTML from transcript messages.

        Args:
            messages: List of transcript entries to render.
            title: Optional title for the output.
            combined_transcript_link: Optional link to combined transcript.
            output_dir: Optional output directory for referenced images.
            page_info: Optional pagination info (page_number, prev_link, next_link).
            page_stats: Optional page statistics (message_count, date_range, token_summary).
        """
        import time

        t_start = time.time()

        # Set output directory for image export (used in "referenced" mode)
        self._output_dir = output_dir
        self._image_counter = 0

        if not title:
            title = "Claude Transcript"

        # Get root messages (tree) and session navigation from format-neutral renderer
        root_messages, session_nav, _ = generate_template_messages(messages)

        # Flatten tree via pre-order traversal, formatting content along the way
        with log_timing("Content formatting (pre-order)", t_start):
            template_messages = self._flatten_preorder(root_messages)

        # Render template
        with log_timing("Template environment setup", t_start):
            env = get_template_environment()
            template = env.get_template("transcript.html")

        with log_timing(
            lambda: f"Template rendering ({len(html_output)} chars)", t_start
        ):
            html_output = str(
                template.render(
                    title=title,
                    messages=template_messages,
                    sessions=session_nav,
                    combined_transcript_link=combined_transcript_link,
                    library_version=get_library_version(),
                    css_class_from_message=css_class_from_message,
                    get_message_emoji=get_message_emoji,
                    is_session_header=is_session_header,
                    page_info=page_info,
                    page_stats=page_stats,
                )
            )

        return html_output

    def generate_session(
        self,
        messages: list[TranscriptEntry],
        session_id: str,
        title: Optional[str] = None,
        cache_manager: Optional["CacheManager"] = None,
        output_dir: Optional[Path] = None,
    ) -> str:
        """Generate HTML for a single session."""
        # Filter messages for this session (SummaryTranscriptEntry.sessionId is always None)
        session_messages = [msg for msg in messages if msg.sessionId == session_id]

        # Get back link to project page (combined transcript or project session index)
        combined_link = None
        if cache_manager is not None:
            try:
                project_cache = cache_manager.get_cached_project_data()
                if project_cache and project_cache.sessions:
                    # Prefer project session index if it exists, otherwise combined
                    if output_dir and (output_dir / "index.html").exists():
                        combined_link = "index.html"
                    else:
                        combined_link = "combined_transcripts.html"
            except Exception:
                pass

        return self.generate(
            session_messages,
            title or f"Session {session_id[:8]}",
            combined_transcript_link=combined_link,
            output_dir=output_dir,
        )

    def generate_projects_index(
        self,
        project_summaries: list[dict[str, Any]],
        from_date: Optional[str] = None,
        to_date: Optional[str] = None,
    ) -> str:
        """Generate an HTML projects index page."""
        title = title_for_projects_index(project_summaries, from_date, to_date)
        template_projects, template_summary = prepare_projects_index(project_summaries)

        env = get_template_environment()
        template = env.get_template("index.html")
        return str(
            template.render(
                title=title,
                projects=template_projects,
                summary=template_summary,
                library_version=get_library_version(),
            )
        )

    def generate_project_sessions_index(
        self,
        project_data: dict[str, Any],
    ) -> str:
        """Generate a lightweight project-level session index page."""
        from ..renderer import TemplateProject

        project = TemplateProject(project_data)
        env = get_template_environment()
        template = env.get_template("project_sessions.html")
        return str(
            template.render(
                title=project.display_name,
                sessions=project.sessions,
                session_count=len(project.sessions),
                message_count=project.message_count,
                formatted_time_range=project.formatted_time_range,
                earliest_timestamp=project.earliest_timestamp,
                latest_timestamp=project.latest_timestamp,
                token_summary=project.token_summary,
                library_version=get_library_version(),
            )
        )

    def is_outdated(self, file_path: Path) -> bool:
        """Check if an HTML file is outdated based on version.

        Returns:
            True if the file should be regenerated (missing version,
            different version, or file doesn't exist).
            False if the file is current.
        """
        html_version = check_html_version(file_path)
        current_version = get_library_version()
        # If no version found or different version, it's outdated
        return html_version != current_version


# -- Convenience Functions ----------------------------------------------------


def generate_html(
    messages: list[TranscriptEntry],
    title: Optional[str] = None,
    combined_transcript_link: Optional[str] = None,
    page_info: Optional[dict[str, Any]] = None,
    page_stats: Optional[dict[str, Any]] = None,
) -> str:
    """Generate HTML from transcript messages using Jinja2 templates.

    This is a convenience function that delegates to HtmlRenderer.generate.

    Args:
        messages: List of transcript entries to render.
        title: Optional title for the output.
        combined_transcript_link: Optional link to combined transcript.
        page_info: Optional pagination info (page_number, prev_link, next_link).
        page_stats: Optional page statistics (message_count, date_range, token_summary).
    """
    return HtmlRenderer().generate(
        messages,
        title,
        combined_transcript_link,
        page_info=page_info,
        page_stats=page_stats,
    )


def generate_session_html(
    messages: list[TranscriptEntry],
    session_id: str,
    title: Optional[str] = None,
    cache_manager: Optional["CacheManager"] = None,
) -> str:
    """Generate HTML for a single session using Jinja2 templates."""
    return HtmlRenderer().generate_session(messages, session_id, title, cache_manager)


def generate_projects_index_html(
    project_summaries: list[dict[str, Any]],
    from_date: Optional[str] = None,
    to_date: Optional[str] = None,
) -> str:
    """Generate an index HTML page listing all projects using Jinja2 templates.

    This is a convenience function that delegates to HtmlRenderer.generate_projects_index.
    """
    return HtmlRenderer().generate_projects_index(project_summaries, from_date, to_date)


def generate_project_sessions_index_html(
    project_data: dict[str, Any],
) -> str:
    """Generate a project-level session index page.

    This is a convenience function that delegates to HtmlRenderer.generate_project_sessions_index.
    """
    return HtmlRenderer().generate_project_sessions_index(project_data)
