"""Factory for system transcript entries.

This module handles creation of MessageContent from SystemTranscriptEntry:
- SystemMessage: Regular system messages with level (info, warning, error)
- HookSummaryMessage: Hook execution summaries

Also provides:
- is_system_message: Check if text content is a system message to filter
"""

from typing import Optional, Union

from ..models import (
    HookInfo,
    HookSummaryMessage,
    SystemMessage,
    SystemTranscriptEntry,
)
from .meta_factory import create_meta


# =============================================================================
# System Message Detection
# =============================================================================


def is_system_message(text_content: str) -> bool:
    """Check if a message is a system message that should be filtered out."""
    system_message_patterns = [
        "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.",
        "<local-command-caveat>",
        "[Request interrupted by user for tool use]",
        "<local-command-stdout>",
    ]

    return any(text_content.startswith(pattern) for pattern in system_message_patterns)


# =============================================================================
# System Message Creation
# =============================================================================


def create_system_message(
    transcript: SystemTranscriptEntry,
) -> Optional[Union[SystemMessage, HookSummaryMessage]]:
    """Create a MessageContent from a system transcript entry.

    Handles:
    - Hook summaries (subtype="stop_hook_summary")
    - Regular system messages with level-specific styling (info, warning, error)

    Args:
        transcript: The system transcript entry to process

    Returns:
        SystemMessage or HookSummaryMessage (with meta attached),
        or None if the message should be skipped (e.g., silent hook successes)

    Note:
        Slash command messages (<command-name>, <local-command-stdout>) are user messages,
        not system messages. They are handled separately.
    """
    if transcript.subtype == "stop_hook_summary":
        # Skip silent hook successes (no output, no errors)
        if not transcript.hasOutput and not transcript.hookErrors:
            return None
        # Create structured hook summary content
        meta = create_meta(transcript)
        hook_infos = [
            HookInfo(command=info.get("command", "unknown"))
            for info in (transcript.hookInfos or [])
        ]
        return HookSummaryMessage(
            has_output=bool(transcript.hasOutput),
            hook_errors=transcript.hookErrors or [],
            hook_infos=hook_infos,
            meta=meta,
        )

    if not transcript.content:
        # Skip system messages without content (shouldn't happen normally)
        return None

    # Create structured system content
    meta = create_meta(transcript)
    level = getattr(transcript, "level", "info")
    return SystemMessage(level=level, text=transcript.content, meta=meta)
