#!/usr/bin/env python3
"""Test cases for the utils module functions."""

import pytest
from claude_code_log.factories import (
    is_bash_input,
    is_bash_output,
    is_command_message,
    is_local_command_output,
    is_system_message,
)
from claude_code_log.utils import (
    should_skip_message,
    should_use_as_session_starter,
    extract_text_content_length,
    create_session_preview,
    get_warmup_session_ids,
    _compact_ide_tags_for_preview,
    FIRST_USER_MESSAGE_PREVIEW_LENGTH,
)
from claude_code_log.models import (
    TextContent,
    ToolUseContent,
    UserTranscriptEntry,
    UserMessageModel,
)


class TestSystemMessageDetection:
    """Test system message detection functionality."""

    def test_is_system_message_caveat(self):
        """Test detection of caveat system messages."""
        caveat_text = "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
        assert is_system_message(caveat_text) is True

    def test_is_system_message_interrupt(self):
        """Test detection of interrupt system messages."""
        interrupt_text = "[Request interrupted by user for tool use]"
        assert is_system_message(interrupt_text) is True

    def test_is_system_message_stdout(self):
        """Test detection of local command stdout system messages."""
        stdout_text = "<local-command-stdout> tags (always at the beginning)"
        assert is_system_message(stdout_text) is True

    def test_is_system_message_local_command_caveat(self):
        """Test detection of local-command-caveat tagged system messages."""
        caveat_text = "<local-command-caveat>Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.</local-command-caveat>"
        assert is_system_message(caveat_text) is True

    def test_is_system_message_normal_text(self):
        """Test that normal text is not detected as system message."""
        normal_text = "This is a regular user message with normal content."
        assert is_system_message(normal_text) is False

    def test_is_system_message_partial_match(self):
        """Test that partial matches don't trigger system message detection."""
        partial_text = "Caveat: This is just a regular caveat, not a system message."
        assert is_system_message(partial_text) is False

    def test_is_system_message_empty_string(self):
        """Test system message detection with empty string."""
        assert is_system_message("") is False

    def test_is_system_message_whitespace_only(self):
        """Test system message detection with whitespace."""
        assert is_system_message("   \n\t  ") is False


class TestCommandMessageDetection:
    """Test command message detection functionality."""

    def test_is_command_message_complete(self):
        """Test detection of complete command messages."""
        command_text = "<command-name>ls</command-name><command-message>List files</command-message>"
        assert is_command_message(command_text) is True

    def test_is_command_message_with_args(self):
        """Test detection of command messages with arguments."""
        command_text = "<command-name>cd</command-name><command-args>/home/user</command-args><command-message>Change directory</command-message>"
        assert is_command_message(command_text) is True

    def test_is_command_message_only_name(self):
        """Test that only command-name tag is not sufficient."""
        command_text = "<command-name>ls</command-name>"
        assert is_command_message(command_text) is False

    def test_is_command_message_only_message(self):
        """Test that only command-message tag is not sufficient."""
        command_text = "<command-message>List files</command-message>"
        assert is_command_message(command_text) is False

    def test_is_command_message_normal_text(self):
        """Test that normal text is not detected as command message."""
        normal_text = "This is a regular message about commands."
        assert is_command_message(normal_text) is False

    def test_is_command_message_empty_string(self):
        """Test command message detection with empty string."""
        assert is_command_message("") is False


class TestLocalCommandOutput:
    """Test local command output detection functionality."""

    def test_is_local_command_output_present(self):
        """Test detection of local command output tags."""
        output_text = "Some text <local-command-stdout>output here</local-command-stdout> more text"
        assert is_local_command_output(output_text) is True

    def test_is_local_command_output_standalone(self):
        """Test detection of standalone stdout tags."""
        output_text = "<local-command-stdout>"
        assert is_local_command_output(output_text) is True

    def test_is_local_command_output_normal_text(self):
        """Test that normal text is not detected as command output."""
        normal_text = "This is regular text without command output tags."
        assert is_local_command_output(normal_text) is False

    def test_is_local_command_output_empty_string(self):
        """Test command output detection with empty string."""
        assert is_local_command_output("") is False


class TestBashCommandDetection:
    """Test bash command input/output detection functionality."""

    def test_is_bash_input_complete(self):
        """Test detection of complete bash input tags."""
        bash_text = "<bash-input>pwd</bash-input>"
        assert is_bash_input(bash_text) is True

    def test_is_bash_input_with_complex_command(self):
        """Test detection with complex bash commands."""
        bash_text = "<bash-input>ls -la /home/user | grep .txt</bash-input>"
        assert is_bash_input(bash_text) is True

    def test_is_bash_input_incomplete(self):
        """Test that incomplete bash input tags are not detected."""
        # Only opening tag
        assert is_bash_input("<bash-input>pwd") is False
        # Only closing tag
        assert is_bash_input("pwd</bash-input>") is False
        # Wrong tag name
        assert is_bash_input("<bash-command>pwd</bash-command>") is False

    def test_is_bash_input_empty_command(self):
        """Test detection of empty bash input."""
        bash_text = "<bash-input></bash-input>"
        assert is_bash_input(bash_text) is True

    def test_is_bash_input_normal_text(self):
        """Test that normal text is not detected as bash input."""
        normal_text = "This is a regular message without bash tags"
        assert is_bash_input(normal_text) is False


class TestBashOutputDetection:
    """Test bash output detection functionality."""

    def test_is_bash_output_stdout_only(self):
        """Test detection of bash stdout."""
        output_text = "<bash-stdout>/home/user</bash-stdout><bash-stderr></bash-stderr>"
        assert is_bash_output(output_text) is True

    def test_is_bash_output_stderr_only(self):
        """Test detection of bash stderr."""
        output_text = "<bash-stdout></bash-stdout><bash-stderr>Error: File not found</bash-stderr>"
        assert is_bash_output(output_text) is True

    def test_is_bash_output_both(self):
        """Test detection with both stdout and stderr."""
        output_text = (
            "<bash-stdout>Output</bash-stdout><bash-stderr>Warning</bash-stderr>"
        )
        assert is_bash_output(output_text) is True

    def test_is_bash_output_stdout_tag_only(self):
        """Test detection with just stdout tag present."""
        output_text = "Some text with <bash-stdout> tag"
        assert is_bash_output(output_text) is True

    def test_is_bash_output_stderr_tag_only(self):
        """Test detection with just stderr tag present."""
        output_text = "Some text with <bash-stderr> tag"
        assert is_bash_output(output_text) is True

    def test_is_bash_output_normal_text(self):
        """Test that normal text is not detected as bash output."""
        normal_text = "This is regular text without bash output tags"
        assert is_bash_output(normal_text) is False

    def test_is_bash_output_empty_tags(self):
        """Test detection of empty output tags."""
        output_text = "<bash-stdout></bash-stdout><bash-stderr></bash-stderr>"
        assert is_bash_output(output_text) is True


class TestMessageSkipping:
    """Test the centralized message skipping logic."""

    def test_should_skip_system_message_without_command(self):
        """Test that system messages without commands are skipped."""
        caveat_text = "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
        assert should_skip_message(caveat_text) is True

    def test_should_not_skip_system_message_with_command(self):
        """Test that system messages with commands are not skipped."""
        command_text = "Caveat: some text <command-name>ls</command-name><command-message>List files</command-message>"
        assert should_skip_message(command_text) is False

    def test_should_not_skip_normal_message(self):
        """Test that normal messages are not skipped."""
        normal_text = "This is a regular user message."
        assert should_skip_message(normal_text) is False

    def test_should_not_skip_command_only_message(self):
        """Test that command-only messages are not skipped."""
        command_text = "<command-name>git</command-name><command-message>Git command</command-message>"
        assert should_skip_message(command_text) is False

    def test_should_skip_interrupt_message(self):
        """Test that interrupt messages are skipped."""
        interrupt_text = "[Request interrupted by user for tool use]"
        assert should_skip_message(interrupt_text) is True


class TestSessionStarterSelection:
    """Test the session starter message selection logic."""

    def test_should_use_normal_message_as_starter(self):
        """Test that normal messages can be used as session starters."""
        normal_text = "Hello, can you help me with this project?"
        assert should_use_as_session_starter(normal_text) is True

    def test_should_not_use_system_message_as_starter(self):
        """Test that system messages cannot be used as session starters."""
        caveat_text = "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
        assert should_use_as_session_starter(caveat_text) is False

    def test_should_use_init_command_as_starter(self):
        """Test that init commands can be used as session starters."""
        init_text = "<command-name>init</command-name><command-message>Initialize project</command-message>"
        assert should_use_as_session_starter(init_text) is True

    def test_should_not_use_other_commands_as_starter(self):
        """Test that non-init commands cannot be used as session starters."""
        command_text = "<command-name>ls</command-name><command-message>List files</command-message>"
        assert should_use_as_session_starter(command_text) is False

    def test_should_not_use_git_command_as_starter(self):
        """Test that git commands cannot be used as session starters."""
        git_text = "<command-name>git</command-name><command-message>Git status</command-message>"
        assert should_use_as_session_starter(git_text) is False

    def test_should_use_message_with_command_name_in_content(self):
        """Test that messages mentioning commands in content can be used as starters."""
        content_text = "I want to run the init command to set up my project."
        assert should_use_as_session_starter(content_text) is True

    def test_should_not_use_empty_string_as_starter(self):
        """Test that empty strings cannot be used as session starters."""
        assert (
            should_use_as_session_starter("") is True
        )  # Empty strings are not system/command messages


class TestTextContentLength:
    """Test the text content length extraction functionality."""

    def test_extract_text_content_length_single_text_item(self):
        """Test length extraction from list with single text item."""
        content = [
            TextContent(type="text", text="Hello world, this is a test message.")
        ]
        assert extract_text_content_length(content) == len(
            "Hello world, this is a test message."
        )

    def test_extract_text_content_length_text_with_whitespace(self):
        """Test length extraction from text with leading/trailing whitespace."""
        content = [TextContent(type="text", text="   Hello world   ")]
        assert extract_text_content_length(content) == len("Hello world")

    def test_extract_text_content_length_empty_list(self):
        """Test length extraction from empty list."""
        content: list = []
        assert extract_text_content_length(content) == 0

    def test_extract_text_content_length_empty_text(self):
        """Test length extraction from list with empty text."""
        content = [TextContent(type="text", text="")]
        assert extract_text_content_length(content) == 0

    def test_extract_text_content_length_whitespace_only(self):
        """Test length extraction from text with whitespace only."""
        content = [TextContent(type="text", text="   \n\t   ")]
        assert extract_text_content_length(content) == 0

    def test_extract_text_content_length_list_with_text(self):
        """Test length extraction from list with text content."""
        text_item = TextContent(type="text", text="Hello world")
        content = [text_item]
        assert extract_text_content_length(content) == len("Hello world")

    def test_extract_text_content_length_list_with_multiple_text(self):
        """Test length extraction from list with multiple text items."""
        text_item1 = TextContent(type="text", text="Hello ")
        text_item2 = TextContent(type="text", text="world!")
        content = [text_item1, text_item2]
        # Each item is stripped, so "Hello " becomes "Hello" (5 chars) + "world!" (6 chars) = 11 chars
        assert extract_text_content_length(content) == 11

    def test_extract_text_content_length_list_with_mixed_content(self):
        """Test length extraction from list with mixed content types."""
        text_item = TextContent(type="text", text="Hello world")
        tool_item = ToolUseContent(
            type="tool_use", id="tool1", name="TestTool", input={"key": "value"}
        )
        content = [text_item, tool_item]
        # Only text content should be counted
        assert extract_text_content_length(content) == len("Hello world")

    def test_extract_text_content_length_list_no_text(self):
        """Test length extraction from list with no text content."""
        tool_item = ToolUseContent(
            type="tool_use", id="tool1", name="TestTool", input={"key": "value"}
        )
        content = [tool_item]
        assert extract_text_content_length(content) == 0


class TestEdgeCases:
    """Test edge cases and error conditions."""

    def test_functions_with_none_input(self):
        """Test that functions handle None input gracefully."""
        # Most functions should handle None by treating it as empty/false
        with pytest.raises(AttributeError):
            is_system_message(None)  # type: ignore
        with pytest.raises(TypeError):
            is_command_message(None)  # type: ignore
        with pytest.raises(TypeError):
            is_local_command_output(None)  # type: ignore

    def test_functions_with_non_string_input(self):
        """Test that functions handle non-string input with TypeError."""
        # All of these should raise TypeError when using `in` with non-string types
        with pytest.raises(TypeError):
            is_command_message(123)  # type: ignore
        with pytest.raises(TypeError):
            is_local_command_output(123)  # type: ignore
        with pytest.raises(AttributeError):
            is_system_message(123)  # type: ignore

    def test_should_skip_message_edge_cases(self):
        """Test edge cases for message skipping logic."""
        # Test with very long system message
        long_caveat = (
            "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
            + "x" * 1000
        )
        assert should_skip_message(long_caveat) is True

        # Test with system message that also has command
        mixed_message = "Caveat: The messages below were generated by the user while running local commands. <command-name>init</command-name><command-message>Init</command-message>"
        assert should_skip_message(mixed_message) is False

    def test_session_starter_edge_cases(self):
        """Test edge cases for session starter selection."""
        # Test with very long init command
        long_init = (
            "<command-name>init</command-name><command-message>"
            + "x" * 1000
            + "</command-message>"
        )
        assert should_use_as_session_starter(long_init) is True

        # Test with init in the middle of command name
        init_middle = "<command-name>reinit</command-name><command-message>Reinitialize</command-message>"
        assert should_use_as_session_starter(init_middle) is False


class TestWarmupMessageFiltering:
    """Test warmup message filtering in session starters."""

    def test_should_not_use_warmup_as_starter(self):
        """Test that 'Warmup' messages are filtered out from session starters."""
        assert should_use_as_session_starter("Warmup") is False

    def test_should_not_use_warmup_with_whitespace_as_starter(self):
        """Test that 'Warmup' with whitespace is filtered out."""
        assert should_use_as_session_starter("  Warmup  ") is False
        assert should_use_as_session_starter("\nWarmup\n") is False
        assert should_use_as_session_starter("\t Warmup \t") is False

    def test_should_use_warmup_in_sentence_as_starter(self):
        """Test that messages containing 'Warmup' in a sentence are not filtered."""
        assert (
            should_use_as_session_starter("Let's warmup with a simple example") is True
        )
        assert should_use_as_session_starter("Warmup exercises are important") is True

    def test_should_not_use_case_sensitive_warmup(self):
        """Test that warmup filtering is case-sensitive (only exact 'Warmup')."""
        # Only exact "Warmup" is filtered, not "warmup" or "WARMUP"
        assert should_use_as_session_starter("warmup") is True
        assert should_use_as_session_starter("WARMUP") is True
        assert should_use_as_session_starter("WarmUp") is True


class TestCompactIDETagsForPreview:
    """Test compact IDE tag rendering for session previews."""

    def test_compact_ide_opened_file(self):
        """Test that <ide_opened_file> is replaced with compact indicator showing full path."""
        text = "<ide_opened_file>The user opened the file /path/to/myfile.py in the IDE.</ide_opened_file>What does this do?"
        result = _compact_ide_tags_for_preview(text)

        assert "üìé /path/to/myfile.py" in result
        assert "<ide_opened_file>" not in result

    def test_compact_ide_opened_file_without_extension(self):
        """Test that files without extensions are handled correctly."""
        text = "<ide_opened_file>The user opened the file /Users/dain/workspace/claude-code-log/justfile in the IDE.</ide_opened_file>Question"
        result = _compact_ide_tags_for_preview(text)

        assert "üìé /Users/dain/workspace/claude-code-log/justfile" in result
        assert "<ide_opened_file>" not in result

    def test_compact_ide_selection_with_path(self):
        """Test that <ide_selection> shows file path when present."""
        text = "<ide_selection>The user selected lines 1 to 10 from /path/to/file.py</ide_selection>Can you explain this?"
        result = _compact_ide_tags_for_preview(text)

        assert "‚úÇÔ∏è /path/to/file.py" in result
        assert "<ide_selection>" not in result

    def test_compact_ide_selection_strips_trailing_colon(self):
        """Test that trailing colons are stripped from file paths in selections."""
        text = "<ide_selection>The user selected the lines 194 to 194 from /path/to/justfile:\nrelease-push\n\nThis may or may not be related.</ide_selection>Question"
        result = _compact_ide_tags_for_preview(text)

        assert "‚úÇÔ∏è /path/to/justfile" in result
        assert "‚úÇÔ∏è /path/to/justfile:" not in result  # No trailing colon
        assert "<ide_selection>" not in result

    def test_compact_ide_selection_without_path(self):
        """Test that <ide_selection> falls back to 'selection' when no path."""
        text = "<ide_selection>some selected code here</ide_selection>Can you explain this?"
        result = _compact_ide_tags_for_preview(text)

        assert "‚úÇÔ∏è selection" in result
        assert "<ide_selection>" not in result

    def test_compact_ide_diagnostics(self):
        """Test that <ide_diagnostics> is replaced with stethoscope emoji."""
        text = '<post-tool-use-hook><ide_diagnostics>[{"severity": "error"}]</ide_diagnostics></post-tool-use-hook>Please fix this.'
        result = _compact_ide_tags_for_preview(text)

        assert "ü©∫ diagnostics" in result
        assert "<ide_diagnostics>" not in result

    def test_compact_multiple_ide_tags(self):
        """Test multiple leading IDE tags are all compacted."""
        text = (
            "<ide_opened_file>The user opened the file /src/file.py in the IDE.</ide_opened_file>"
            "<ide_selection>code</ide_selection>"
            "Question here"
        )
        result = _compact_ide_tags_for_preview(text)

        assert "üìé /src/file.py" in result
        assert "‚úÇÔ∏è" in result
        assert "Question here" in result

    def test_compact_ide_tags_no_file_path(self):
        """Test fallback when no file path can be extracted."""
        text = "<ide_opened_file>Some content without a file path</ide_opened_file>Question"
        result = _compact_ide_tags_for_preview(text)

        assert "üìé file" in result
        assert "<ide_opened_file>" not in result

    def test_compact_ide_tags_preserves_other_content(self):
        """Test that content without IDE tags is preserved."""
        text = "This is a normal message without any IDE tags"
        result = _compact_ide_tags_for_preview(text)

        assert result == text

    def test_embedded_ide_tags_not_replaced(self):
        """Test that IDE tags embedded in message content (e.g., JSONL) are NOT replaced."""
        text = (
            "<ide_opened_file>The user opened the file /path/to/file.py in the IDE.</ide_opened_file>"
            'Error: {"content":[{"text":"<ide_selection>embedded tag</ide_selection>"}]}'
        )
        result = _compact_ide_tags_for_preview(text)

        # Leading tag should be compacted
        assert "üìé /path/to/file.py" in result
        assert "<ide_opened_file>" not in result

        # Embedded tag should be preserved (not replaced)
        assert "<ide_selection>embedded tag</ide_selection>" in result

    def test_only_leading_ide_tags_processed(self):
        """Test that only IDE tags at the start are processed, not tags later in text."""
        text = "Some text first <ide_selection>not at start</ide_selection> more text"
        result = _compact_ide_tags_for_preview(text)

        # Since there's no leading IDE tag, text should be unchanged
        assert result == text
        assert "<ide_selection>" in result  # Tag preserved

    def test_compact_bash_input(self):
        """Test that <bash-input> is replaced with terminal emoji and command."""
        text = "<bash-input>uv run ty check</bash-input>"
        result = _compact_ide_tags_for_preview(text)

        assert "üíª uv run ty check" in result
        assert "<bash-input>" not in result

    def test_compact_bash_input_with_following_text(self):
        """Test bash-input followed by other text."""
        text = "<bash-input>git status</bash-input>What does this show?"
        result = _compact_ide_tags_for_preview(text)

        assert "üíª git status" in result
        assert "What does this show?" in result
        assert "<bash-input>" not in result

    def test_compact_bash_input_truncates_long_commands(self):
        """Test that very long commands are truncated."""
        long_command = "very-long-command-that-exceeds-fifty-characters-in-total-length"
        text = f"<bash-input>{long_command}</bash-input>"
        result = _compact_ide_tags_for_preview(text)

        # Should be truncated to 47 chars + "..."
        assert "üíª " in result
        assert len(result.replace("üíª ", "")) <= 50
        assert result.endswith("...")

    def test_compact_bash_input_with_ide_tags(self):
        """Test bash-input combined with IDE tags."""
        text = (
            "<ide_opened_file>The user opened the file /src/test.py in the IDE.</ide_opened_file>"
            "<bash-input>pytest test_file.py</bash-input>"
            "Run this test"
        )
        result = _compact_ide_tags_for_preview(text)

        assert "üìé /src/test.py" in result
        assert "üíª pytest test_file.py" in result
        assert "Run this test" in result

    def test_embedded_bash_input_not_replaced(self):
        """Test that bash-input tags embedded in content are NOT replaced."""
        text = 'Error message: {"content":"<bash-input>embedded</bash-input>"}'
        result = _compact_ide_tags_for_preview(text)

        # No leading tag, so text should be unchanged
        assert result == text
        assert "<bash-input>embedded</bash-input>" in result


class TestCreateSessionPreview:
    """Test session preview creation with IDE tags and truncation."""

    def test_create_session_preview_uses_compact_ide_tags(self):
        """Test that create_session_preview uses compact IDE tags with full path."""
        text = "<ide_selection>The user selected lines 1 to 10 from /src/utils.py</ide_selection>Can you refactor this function?"
        preview = create_session_preview(text)

        assert "‚úÇÔ∏è /src/utils.py" in preview
        assert "Can you refactor this function?" in preview
        assert "<ide_selection>" not in preview

    def test_create_session_preview_selection_fallback(self):
        """Test that selection without path shows 'selection'."""
        text = "<ide_selection>some code here</ide_selection>Can you explain?"
        preview = create_session_preview(text)

        assert "‚úÇÔ∏è selection" in preview
        assert "<ide_selection>" not in preview

    def test_create_session_preview_handles_truncation(self):
        """Test that preview is truncated after IDE tag compacting."""
        long_message = "x" * (FIRST_USER_MESSAGE_PREVIEW_LENGTH + 100)
        preview = create_session_preview(long_message)

        assert preview.endswith("...")
        assert len(preview) == FIRST_USER_MESSAGE_PREVIEW_LENGTH + 3  # +3 for "..."

    def test_create_session_preview_multiple_ide_tags(self):
        """Test preview creation with multiple IDE tags."""
        text = (
            "<ide_opened_file>The user opened the file /src/test.py in the IDE.</ide_opened_file>"
            "<ide_selection>Lines 1-10</ide_selection>"
            "Please review this code for bugs"
        )
        preview = create_session_preview(text)

        assert "üìé /src/test.py" in preview
        assert "‚úÇÔ∏è" in preview
        assert "Please review this code for bugs" in preview


class TestGetWarmupSessionIds:
    """Test bulk warmup session ID detection."""

    def _create_user_entry(
        self, session_id: str, content: str, uuid: str
    ) -> UserTranscriptEntry:
        """Helper to create a UserTranscriptEntry."""
        return UserTranscriptEntry(
            type="user",
            sessionId=session_id,
            parentUuid=None,
            isSidechain=False,
            userType="external",
            cwd="/test",
            version="1.0.0",
            message=UserMessageModel(
                role="user", content=[TextContent(type="text", text=content)]
            ),
            uuid=uuid,
            timestamp="2025-01-01T10:00:00Z",
        )

    def test_get_warmup_session_ids_multiple_sessions(self):
        """Test get_warmup_session_ids correctly identifies warmup sessions."""
        messages = [
            self._create_user_entry("warmup-session", "Warmup", "msg-1"),
            self._create_user_entry("warmup-session", "Warmup", "msg-2"),
            self._create_user_entry("normal-session", "Hello", "msg-3"),
            self._create_user_entry("mixed-session", "Warmup", "msg-4"),
            self._create_user_entry("mixed-session", "Can you help?", "msg-5"),
        ]
        warmup_ids = get_warmup_session_ids(messages)

        assert warmup_ids == {"warmup-session"}

    def test_get_warmup_session_ids_no_warmup(self):
        """Test when there are no warmup sessions."""
        messages = [
            self._create_user_entry("session-1", "Hello", "msg-1"),
            self._create_user_entry("session-2", "Help me", "msg-2"),
        ]
        warmup_ids = get_warmup_session_ids(messages)

        assert warmup_ids == set()

    def test_get_warmup_session_ids_empty(self):
        """Test with empty messages list."""
        warmup_ids = get_warmup_session_ids([])

        assert warmup_ids == set()
